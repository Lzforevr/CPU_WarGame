[
    {
        "typename": "基础挑战",
        "games": [
            {
                "id": 0,
                "name": "内核地址破坏者（KASLR Breaker）",
                "desc": "从Linux内核4.12开始，默认情况下KASLR（内核地址空间布局随机化）处于活动状态。这意味着内核的位置（以及映射整个物理内存的直接物理映射）随着每次重新启动而变化。\n在这一游戏中，你将尝试使用Meltdown来泄露直接物理映射的（秘密）随机化，当你修改的代码运行成功后，将会显示一段文字：\n[+] Direct physical map offset: 0xffff880000000000（例），\n其中这串十六进制的数字就是通过漏洞直接得到的随机化地址偏移量！\n值得注意的是，你在后面游戏中实现的Poc都需要基于这一串地址~"
            },
            {
                "id": 1,
                "name": "揭露内存的面纱（Physical Memory Reader）",
                "desc": "这个游戏通过直接读取物理内存从不同的进程中读取内存的值。\n原则上，这个程序应该可以读取任意的物理地址。然而，由于物理内存包含许多非人类可读的数据，我们将在你提交游戏文件后，自动运行一个测试文件（secret.c），它将人类可读的字符串放入内存，并直接提供此字符串的物理地址。此后，如果你的程序运行成功，将返回类似下面的内容：\n[+] Physical address : 0x390fff400\t//真正的物理地址\n[+] Physical offset : 0xffff880000000000 //内核地址偏移量\n[+] Reading virtual address: 0xffff880390fff400\nIf you can read this, this is really bad //secret.c所写入的可读字符串"
            },
            {
                "id": 2,
                "name": "可靠度vs命中率（Reliability Test）",
                "desc": "众所周知，物理内存的可靠性与Poc代码读取这一内存的命中率是呈负相关的！\n此程序的目的是通过不断重复进行内存读取，利用缓存侧信道攻击来泄露 secret 变量的值（secret变量在每次运行时随机生成）。在攻击中，每个循环迭代都会读取一个物理地址中的数据，并检查是否与 secret 的值相等。根据攻击结果，会增加相应的计数器，并输出攻击成功率和读取的数值数量。\n假如你的代码运行成功，它会输出：\n[-] Success rate: 99.93% (read 1354 values) （例）"
            }
        ]
    }
]